
#+DATE: <2013-07-18 木>
#+OPTIONS: tex:t latex:t
#+LATEX_CLASS: jsarticle
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+infojs_opt: view:info path:./org-info.js toc:t ltoc:nil ftoc:nil
#+infojs_opt: mouse:#eeeeee buttons:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />


* SASTRIPS

完全ドメイン依存の研究は少しあるが
PDDLの構造から特殊クラスに移そうという試みはそんなにない。

必要なのは

+ 理論はできてる
+ あとは実証すればいい

特殊ソルバを用意する

その効果はあるか?

比較対象: FD
サブクラスに対して自動特殊化と比べる。

ランダムなPDDLの生成

シュタイナーはできてる

*自分の仕事:検出、変換、PDDL作成*

** テスト問題の作り方

実用性のある問題の作り方にもコツがある

*論文読む*

* ループ化

IHIの話

** 前提

+ 場所を埋める数は決め打ち(5個)
+ 並列ラインは今は考えないことにする。直線的
+ 作業の順番もわかっている
+ 作業する場所の数も決定済み
+ 何が動くのかも決定済み(base)
+ 複数baseの場合は考えない
+ 切削・分割は考えない。組立だけ。

** 練り上げ

+ 何が動くものなのかわからないとき検知できるか?
+ 一番移動量が大きいのがベース?
  + 必要ない。別に、PDDLの中にかいてもらえばいい。
  + ただ、かいてもらったものを検知する必要はある

実際こういうシステムを作る場合何が自然なのか?

+ プランナの結果無駄に待ってることがあることは許す
+ 製品の製造上で適切でない行いをすることは許さない。
  + そういうことはないものとして考える。
+ 初期状態の作り方 --- プランナにまかせる
+ 定常状態でbaseが何個あるかを決める

(デザイン時点でこれぐらいは考えておく。)

名前をつける

+ 少数ベースプラン
  + --- 一つまたは2つのベースの製作のため作ったプラン プ
    ランナの解ける範囲のプラン
  + これのプランの途中が定常状態の一部になっている(かもしれない)
  + 最適な定常状態ではないかもしれない
+ 多数ベースプラン
  + --- 100以上のベースの製作のため作ったプラン
  + FDで直接には解けない

** 最適なループ点を探すにはどうすればいいか?

+ 直接ループ店を探す方法
+ 少数ベースプランを最適化してそこから候補を選ぶ方法
  + 効率の良い/悪い少数ベースプランからつくるループプランは効率が良さそ
    う/悪そう(ヒューリスティクス)

場所が空いているのは効率が悪そう。

+ 順番がひとつに決定されている、とは?
  + 一台の塗装機で青も赤も塗れる。
  + 一台のネジ閉め機でどの箇所でも閉められる。
  + この場合、同じネジしめきを複数回訪れることになる。

締めてー塗ってー締めてのときに一旦戻る必要がある?

+ 場所が後戻りを必要なとき、場所に空きが必要?
+ 必要でないときには空きが必要ない??
+ 理論的な検証が必要かも

* 制作コスト見積もり

流れ

スケジュールを見積もらないといけない
後ろから考えて。実験時間も考慮に入れる
ループ店を考えはじめるところは8月中でないと行けない。
そうでないとどうしても間に合わない。

1. [X] オブジェクトからPDDLへの出力関数 -- 3
   + generic-function (UNPARSE-PDDL obj) $\rightarrow$ cons
2. テストに使うPDDLの作成 [2/4]
   1. [X] とりあえず手作業で作成 --- 3
   2. [X] タイプチェッカ (必要か?) --- 2
   3. [ ] ランダムな(難しい/現実的な)PDDLファイルの作成 --- 5
   4. [ ] 問題の難易度を推計する関数 --- 3
      + 今井さん問題にも関わってくる
3. [X] PDDLファイル読み込み --- 3
   1. [X] action-cost 対応 --- 3
4. [X] 場所とベースの検知 -- 1
   + typingすればいい
5. [X] テンプレートの書き方
6. [X] 少数ベースプランをFDで作成  -- 1
   + シェル経由でFDに投げる
7. [X] スケジューラに投げる -- 5
   1. [X] 並列最適化ライブラリの作成 --- 3
   2. [X] スケジューラ作成 --- 2
8. [X] 生成されたプランを実行して状態遷移を得る。 -- 1
   + base数 $n=1$ は少なくとも必要
   + $n=(\mbox{少数})$ は必要か?
   + 1ベースの動き方のことを _工程_
   + n=1で得られた工程のことを _基本工程_
   + 1ベースあたりの _基本工程長_ l_1
9. [X] 検知すべきもの
   + [X] mutex
10. [X] 4,6 をもとに、ベースがどう動くかをチェックする -- 2
    + 場所の列を得る 工程 -- 1
      + 場所とは何か?
	+ 腕に運ばれるなら腕も場所か?
	+ とりあえずはベタ書きだが、将来的には一般化を考える
      + 取り付けられる部品のことは考えなくてもいいのか?
	+ 同じmove-armでも、move-arm-holdingに分ける必要があった。
	+ 同様に、運ぶものの型によって、実はアクションは変わるはずだ。
          (ディスパッチされるはず)
	+ だから、特定子によって特定化されたアクションごとに、移動型コ
          マンドを抽出すればいい。
    + 後戻りが必要かのチェック。 -- 1
      + 流れの中に同じ場所が複数現れるかどうか見るだけ
11. [-] steady-state PDDLの作成。 -- 16
    1. [X] mutex の条件を満たす steady state (ss) を生成 -- 5
       1. この時点で59001個のsteady-state
    2. [X] ループできない ss を枝刈りする -- 5
       1. [X] mutex だけに着目した A*探索
	  1. [X] A* の Red-Black-Tree による Priority Queue 化
	  2. [X] +よりよいヒューリスティクス+
	  3. 実は、直列でのループの必要時間はどれも同じだとわかった。
             + 証明: どのループプランも、動かす場所の組み合わせが同じ
	       + 終了状態18
	       + (0,)3,16->3,16,(18) 総移動数は
		 + (3-0)+(16-3)+(18-16) = 18-0 = 18
	       + (0,)3,5,7 -> 3,5,7,(18) 総移動数は
		 + (3-0)+(5-3)+(7-5)+(18-7) = 18-0 = 18
       2. [X] ループのゴール状態が同一のものは探索しない
	  1. これで探索する ss の数が半数に減る (5760)
       3. [X] 他の種類のループの途中状態に現れたものは探索しない
	  1. これはあまり減らなかった. 313個
       4. [X] 最終的に882の候補に絞られた.
    3. [-] steady state をヒューリスティックに並べる -- 3
       1. [X] +unit plan (base数 n=1 のプラン) から、1ループのコストを推計+
       2. [ ] ループの中を並列スケジュール化したときのコストの見積もり
    4. [X] mutexだけで決めることのできない要素(*)を決定する -- 3
       1. バグあり、修正中
12. [ ] 並べられた順に steady-state を FDに投げる
    1. [ ] プランを得る -- 1
    2. [ ] (*) に起因する無駄な要素を最適化する -- 5
    3. [ ] ループ２つを融合 -- 1
       1. [ ] 最適化ライブラリに食わせる。ループ間のバトン渡しを最適化 -- 3
    4. [ ] 全プランの生成 -- 2
       1. [ ] 初期状態 -> ss初期状態 プラン (prelude) の生成 -- 1 (haskell envy...)
       2. [ ] ss終了状態 -> 終了状態 プラン (finale) の生成 -- 1
    5. [ ] プランの比較 -- 1

* 検証

** 「場所」?

+ 「場所」の列を抽出するのはどうやらおかしいような気がする
+ というか場所って何?
+ 普通に状態列でいい気がしてきた。
+ 一般化するなら場所の概念は多次元になるから。
+ ていうか、状態空間の「状態」って「場所」って概念と意味の重なりがある
  と思う


一次元の場所
: (at b1 x1)

二次元の場所(x座標、y座標)
: (2d-at b1 x1 y1)

implicitな二次元の座標
: (at b1 x1)
: (job-done b1 job1)

座標の指定子は変わることもある
: (at b1 x1) -> (lifting b1 hoist)

座標の次元数も変わることがある
: (2d-at b1 x1 y1) -> (lifting b1 hoist)

まあそんなところ。

** プランからbaseに関連した状態を抽出する

cell-asembly ドメイン + 少数ベース問題 で Fast Downward プランナを実行し、
生成されたプランを自作シミュレータで再現した。
シミュレーションによって、各アクション間の状態が得られる。
状態とは命題 (/fact/) の列。

この命題列から、引数に base をとっているものだけを抽出すれば、
少数ベースプランで base の状態がどのように移り変わるかがわかる。

抽出した結果が下のようなもの。
以下 引数からbaseを省略。


| action       | (at ?base ?pos) | (job-done ?base ?job) | (hold ?arm ?base) |
|--------------+-----------------+-----------------------+-------------------|
|              | table1          | nothing               |                   |
|--------------+-----------------+-----------------------+-------------------|
| eject        |                 |                       |                   |
|--------------+-----------------+-----------------------+-------------------|
|              |                 | nothing               | *arm1*            |
|--------------+-----------------+-----------------------+-------------------|
| move-arm     |                 |                       |                   |
|--------------+-----------------+-----------------------+-------------------|
|              |                 | nothing               | arm1              |
|--------------+-----------------+-----------------------+-------------------|
| set          |                 |                       |                   |
|--------------+-----------------+-----------------------+-------------------|
|              | *machine*       | nothing               |                   |
|--------------+-----------------+-----------------------+-------------------|
| assemble-    |                 |                       |                   |
| with-machine |                 |                       |                   |
|--------------+-----------------+-----------------------+-------------------|
|              | machine         | *screwed*             |                   |
|--------------+-----------------+-----------------------+-------------------|
| eject        |                 |                       |                   |
|--------------+-----------------+-----------------------+-------------------|
|              |                 | screwed               | *arm1*            |
|--------------+-----------------+-----------------------+-------------------|
| move-arm     |                 |                       |                   |
|--------------+-----------------+-----------------------+-------------------|
|              |                 | screwed               | arm1              |
|--------------+-----------------+-----------------------+-------------------|
| ...          |                 |                       |                   |
|              |                 |                       |                   |

一般化により腕も場所の一部となる。
腕も場所だというのは違和感があるが、実は問題がない。

最もわかり易い例としては天動説と地動説。
*地球が中心なのか?* それとも、 *太陽が中心なのか?*
実は座標系の問題だけであって、何も問題がない。
だって *銀河系の中心が宇宙の中心* でも言い訳だし、
*銀河間空間* に宇宙の重心があるかもしれない。よくわからない。

同様に、 *move-arm* という動作は、実は腕を回転させるアクションではなく、
/腕は固定したまま工場全体を回転させるアクション/ なのかもしれないし、
/腕は固定したまま宇宙を回転させるアクション/ かもしれないのだ。

** mutexでない種類の述語については無視

述語 =job-done= は、複数のベースが同時に同じ状態にいても問題ない述語で
ある。こいつらは「場所」という概念から排除しないといけない。その排除の
基準は、 =job-done= に対応する *mutex 述語* があるかどうかにある。

+ Mutex とは　Mutual Exclusion (排他)の略。
+ 別の言葉で言うと、資源数1の資源制約。
+ 資源が２以上の資源制約は、ラインに同種の機械が２つあることに対応

owner $o(P)$ とmutex $\mu (P')$ のペアについて、

+ $P=params(o) = (\ldots p_i \ldots )$
+ $P'=params(\mu ) = (\ldots p'_j \ldots )$ 
+ $P' \subset P$
+ $\mbox{indices}(o,\mu ) : P \mapsto P'$
+ $\forall X; o(X) \rightarrow \mu(X') \land
        \lnot o(X) \rightarrow \lnot \mu(X')$
  + where $X$ is an instantiation of $P$
  + and $X'=\mbox{indices}(o,\mu)(X)$

mutexは「使用中」か「開放」かの値を持つので、ドメインによっては 「開放」
状態を表す述語のみを持つ場合もありうる。そういう述語 $r(P)$ については、

+ $\forall X; o(X) \rightarrow \lnot r(X') \land
        \lnot o(X) \rightarrow r(X')$
  + where $X$ is an instantiation of $P$
  + and $X'=\mbox{indices}(o,r)(X)$

これらを用いると、ドメインのアクションの追加効果と削除効果を見ることで、
ownerとmutex/releaseのペアを得ることができる。
なお、typingが有効になっているときには、それを考慮しないといけない。

| owner             | at           | hold               |
|-------------------+--------------+--------------------|
| release predicate | (clear,etc.) | free               |
| mutex predicate   | base-present | (arm-grabbing,etc) |

この知識を使うと、状態遷移から =job-done= を取り除けて

|                       | at      | hold |
|-----------------------+---------+------|
|                       | table1  |      |
|-----------------------+---------+------|
| eject                 |         |      |
|-----------------------+---------+------|
|                       |         | arm1 |
|-----------------------+---------+------|
| move-arm              |         |      |
|-----------------------+---------+------|
|                       |         | arm1 |
|-----------------------+---------+------|
| set                   |         |      |
|-----------------------+---------+------|
|                       | machine |      |
|-----------------------+---------+------|
| assemble-with-machine |         |      |
|-----------------------+---------+------|
|                       | machine |      |
|-----------------------+---------+------|
| eject                 |         |      |
|-----------------------+---------+------|
|                       |         | arm1 |
|-----------------------+---------+------|
| move-arm              |         |      |
|-----------------------+---------+------|
|                       |         | arm1 |
|-----------------------+---------+------|

+ この表を見ると、さらに at と hold は排他的であることがわかる。

** baseの状態に変更のない部分はまとめる

+ 状態に変更の無い部分列はひとつのまとまりとして考えるべき。

|                       | at      | hold | change? |
|-----------------------+---------+------+---------|
|                       | table1  |      |         |
|-----------------------+---------+------+---------|
| eject                 |         |      | yes     |
| move-arm              |         |      | no      |
|-----------------------+---------+------+---------|
|                       |         | arm1 |         |
|-----------------------+---------+------+---------|
| set                   |         |      | yes     |
| assemble-with-machine |         |      | no      |
|-----------------------+---------+------+---------|
|                       | machine |      |         |
|-----------------------+---------+------+---------|
| eject                 |         |      | yes     |
| move-arm              |         |      | no      |
|-----------------------+---------+------+---------|
|                       |         | arm1 |         |
|-----------------------+---------+------+---------|


# ** 一つのベースが同時にacquireできないmutexをまとめる

# + 以下の例では、 mutex から mutex にしか動けない。
# + baseが各状態で mutexを _一つ_ 占有している。
#   + グラフ構造を検出できるかも?
#   + 二部グラフ?
#   + 二部グラフ以外でも適用可能な気がする
# + この戦略だと、アクション列を得た時にしか検知できない。
#   + ドメインから直接類推できるか?
#     + mutex1 が解放されるときは(delete effect) mutex2 が使われている。
#     + mutex1 が解放されているときは(precond) mutex2 が使われている。

# | action                | acquire-place-mutex | change? |
# |-----------------------+---------------------+---------|
# |                       | table1              |         |
# |-----------------------+---------------------+---------|
# | eject                 |                     | yes     |
# | move-arm              |                     | no      |
# |-----------------------+---------------------+---------|
# |                       | arm1                |         |
# |-----------------------+---------------------+---------|
# | set                   |                     | yes     |
# | assemble-with-machine |                     | no      |
# |-----------------------+---------------------+---------|
# |                       | machine             |         |
# |-----------------------+---------------------+---------|
# | eject                 |                     | yes     |
# | move-arm              |                     | no      |
# |-----------------------+---------------------+---------|
# |                       | arm1                |         |
# |-----------------------+---------------------+---------|
# | ...                   |                     |         |
# |                       |                     |         |

** ベースあたりの場所の列(基本工程)に対して、ありうるsteady state配置を探す

+ domain は、 owner/mutex が何種類あるかを規定する。
+ problem は、環境中に実際に mutex となるオブジェクトが何個あるかを規
  定する。
+ mutex の数は、 問題ごとに有限個である。

steady state を得るためには、有限個の mutex を

+ 何個の base に
+ 基本工程のどの時点で
+ どのような配分で

使わせるか、を決定しないといけない。

#+BEGIN_NOTE
もちろん、それを決めた後でも状態が未確定のオブジェクトがある。例えば、
steady state における arm の位置などだ。それらが適切に配置されないと、
ループのたびに、腕が或る場所にわざわざ戻るようなプランができてしまう。
これは別の章で考える。
#+END_NOTE

手法は 全探索 and 枝刈り による。

+ 基本工程内の早い位置に、 mutex による制約を加味しながらベースを配置していく。
+ すでに配置したオブジェクトによって使われているmutexがある列には配置
  できない。
  + 例: ss1 に対して、 ベースを 追加で movement 2 に配置することはできない。
    + 理由 -- mutex a が b1 によってすでに使われている。

こうやって埋めていくと、沢山のsteady state ができる。


|           | mutex   | mutex   | mutex   |   |           |        |       |       |       |
|           | owner 1 | owner 2 | owner 3 |   | examples  |        |       |       |       |
|           |         |         |         |   | of steady | ss1    | ss2   | ss 3  | ss 4  |
|  movement | mutex   | mutex   | mutex   |   | states    |        |       |       |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         1 | a       |         |         |   |           | b1     |       |       |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         2 | a       |         | c       |   |           |        | b1    |       |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         3 |         | b       | c       |   |           | b2     |       | b1    |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         4 |         | b'      | c       |   |           |        |       |       | b1    |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         5 | a'      |         | c       |   |           |        |       |       |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         6 | a'      |         | c'      |   |           | b3     | b2    | b2    | b2    |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         7 |         | b       | c'      |   |           |        |       |       |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         8 |         | b'      | c'      |   |           |        |       |       |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|         9 |         | b''     | c'      |   |           |        |       |       |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
| 10(final) |         |         |         |   |           |        |       |       |       |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|
|           |         |         |         |   | used      | a,a'   | a,c   | b,c,  | b',c, |
|           |         |         |         |   | mutices   | b,c,c' | a',c' | a',c' | a',c' |
|-----------+---------+---------+---------+---+-----------+--------+-------+-------+-------|


** 重複を除く


steady state は loop の開始点を示すものだ。
この開始地点が完全一致している場合はもちろん重複として取り除くことがで
きる。
しかし、実は終了地点についても重複を検出することができる。
ループの終了直前、もはや追加のベースを =carry-in= から持ってくるだけの
時点まで行った時の状態を、以降 /end-of-loop state/ すなわち /eol
state/  と呼ぶ。

例えば、基本工程の長さが3で、

1. movement =(1 2)= に =b1= =b2= を置く配置と
2. movement =(0 2)= に =b1= =b2= を置く配置

があるとする。このとき、それぞれの配置についてのループの終了直前の状態
は、以下のようになる。基本工程の長さが3であるとき、インデックス3は
=base= が工程から出たことを意味していることに注意すること。(インデック
ス3は工程を終了しているのでmutexを消費しない)

1. ループ1: =(1 2)= --- =(2 3)=
   + =b2= が2から出口に移動し、続いて =b1= が1から2に移動
2. ループ2: =(0 2)= --- =(2 3)=
   + =b2= が2から出口に移動し、続いて =b1= が0から2に移動

この場合、ループ2はループ1と同一。なぜなら、終了状態の後ループを続ける
ためには、補充分の新たなベース =b0=
を 工程 =-1= からループ初期状態に移動させるから。
これで候補を半分ぐらいにできた。
なお、cell-assembly の場合 5760 > 2881

** ありうる steady state に対して、ループできないものを枝刈りする

たとえ steady-state の時点ですべての mutex 関係が満たされていたとして
も、それがループの始点かつ終点として適切であるかどうかは自明ではない。
多数のbase を同時に基本工程に入れるわけだから、ループの途中で

+ dead lock に陥る場合
+ resource starvation に陥る場合

がある。しかし、我々はmutexの列を持っているので、重いプランナを回さずとも、
mutex の遷移だけを考える簡易プランナでそれらの一部を検出することができる。
(relaxed plan と考えられる)

+ 例: ss1は回せるか?
  + 初期状態
    + b1: 1>2 は不可能(cがb2とconflict)
    + b2: 3>4 は可能
    + b3: 6>7 は不可能(bがb2とconflict)
    + 結果: b2をすすめる 3>4
  + b2が4にいるので b3 が 7 にすすめる b1 は進めない
  + b2が5にすすめる
  + b3が8,9,10に進んで終了
  + b2が6に進んで終了
  + b1が3に進んで終了
  + b0を生成して1に進んで終了
  + ss1は回せる

A*探索を用いて検証。ヒューリスティクス関数は、

$(\mbox{ベースの数}) - (\mbox{eolとマッチしている状態の数})$
*** dead lock の例

STT: pddl-atomic-state (fact)

#+BEGIN_SRC lisp
(((STT HOLD ((O ARM1 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (O GASKET-MACHINE ∈ MACHINE))))
 ((STT HOLD ((O ARM1 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (O TABLE1 ∈ TABLE))))
 ((STT HOLD ((O ARM2 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (O SCREW-MACHINE-A ∈ MACHINE))))
 ((STT HOLD ((O ARM2 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (O OILING-MACHINE ∈ MACHINE))))
 ((STT HOLD ((O ARM2 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (O TABLE2 ∈ TABLE))))
 ((STT HOLD ((O ARM2 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (O SCREW-MACHINE-C ∈ MACHINE))))
 ((STT HOLD ((O ARM2 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (O TABLE2 ∈ TABLE))))
 ((STT HOLD ((O ARM1 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (O INSPECTION-MACHINE ∈ MACHINE))))
 ((STT HOLD ((O ARM1 ∈ ARM) (O B-0 ∈ BASE))))
 ((STT AT ((O B-0 ∈ BASE) (CONST TABLE-OUT ∈ TABLE)))))
#+END_SRC

配置 1,6,7,11,16,17 は dead lock

| at        | hold     |    | step 0 | step 1 | step 2      |
|-----------+----------+----+--------+--------+-------------|
|           | arm1     |  0 |        |        |             |
| gasket    |          |  1 | b      | b      | b           |
|           | arm1     |  2 |        |        |             |
| table1    |          |  3 |        |        |             |
|           | arm2     |  4 |        |        |             |
|-----------+----------+----+--------+--------+-------------|
| screq     |          |  5 |        |        |             |
|           | arm2     |  6 | b      | b      | b(deadlock) |
| oiling    |          |  7 | b      | b      | b(deadlock) |
|           | arm2     |  8 |        |        |             |
| table2    |          |  9 |        |        |             |
|-----------+----------+----+--------+--------+-------------|
|           | arm2     | 10 |        |        |             |
| screw     |          | 11 | b      | b      | b(deadlock) |
|           | arm2     | 12 |        |        |             |
| table2    |          | 13 |        |        |             |
|           | arm1     | 14 |        |        |             |
|-----------+----------+----+--------+--------+-------------|
| inspec    |          | 15 |        |        |             |
|           | arm1     | 16 | b      | b      |             |
| table-out |          | 17 | b      |        | *b*         |
| (finish)  | (finish) | 18 |        | *b*    | b           |
|           |          |    |        |        |             |

#+BEGIN_NOTE
資源を全部appendして検出していたけど、
次状態で必要な資源ごとに分類した
ほうがチェックが早そう。
#+END_NOTE

1 6 7 11 16 17
0 5 6 10 15 16

** steady state をヒューリスティックに並べる

少数ベースプランがあるため、ループを回す際の総コストが見積もれる。

+ 例えば多数ベースプランで 3>4に移動するコストは、基本工程で 3>4 に
  移動するコストより大きいはずだ。
+ admissibleかも

+ mutex だけを考えた場合の plan のコストの和で steady state を並べ
  る
+ 短い見積りのものから Fast Downward に投げる

こうすることで、よりよい satisfiable plan が 制限時間内に得られる。

*** 考え1 (古)
この時、最大base数は二部グラフにおける何に制限さ
れる?

+ もし腕が100本あって、機械が２つしかなかったら
  + 最初の場所と最後の場所(どちらもmutexなし)への移動のため、ライン上
    には3つおいておくことができる。
  + 4つ以上置くと、機械の場所が律速となるので無駄
    + 計算量が増えるだけで最適化に貢献しない
    + ループ内の探索の傾向として、ライン上のbaseの数が増えると計算量は増える
+ 腕が1本で機械が5個あったら
  + 最大で4個まではおける。
    + 作業の時間が長い場合
  + 最小で一つ。
    + 作業の時間が短い場合。移動コストが大きい


# ** 後戻りが必要なときについての考え

# + 少数ベースプランの状態遷移の中からループの候補を選ぶ。
#   + $n=1$ ならループ長は $l_1$
#   + $n=2$ で $l_2 \geq \frac{l_1}{2}$
#     + 短調増加のはず
# + *並列性・スケジューラのことは考えなくていい* はず(なんだけど・・・)
# + インデックスがひとつ増えているようなものがあればループの候補
# + n=1でどうやってループ検出するのか？
#   + 基本工程をいくつかに分割していく
#     + 例えば、 $l_1 = ij$ のとき $n=i,l_i=j$ に分けてみる
#     + _部分工程_
#     + ただし、 $n$ が増えると困る
#   + 割り算にかんけいなく分割もできる
#     + 短くなった部分工程では、他の工程が終わるのを待って過ごす
#     + 部分工程長に制限がない
# + n=2とかでループは出来るのか?
#   + #をカラのテーブルとする
#   + ２つともスタート地点にある状態で実行する方法
#     + 局所的なループは生成できる
#       + 10##### $\rightarrow$ #10#### 
#       + #10#### $\rightarrow$ ##10###
#       + インデックスがひとつずれる
#   + 一つをスタート地点、一つを基本工程の真ん中辺りのところにお
#     いてみる方法
#     + 1##0### $\rightarrow$ ###1##0
# + ループの中では少数ベースのベースの数nしかテーブルが埋まらない




